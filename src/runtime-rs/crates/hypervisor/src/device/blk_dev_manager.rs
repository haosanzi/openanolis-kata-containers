// Copyright (c) 2019-2022 Alibaba Cloud
// Copyright (c) 2019-2022 Ant Group
//
// SPDX-License-Identifier: Apache-2.0
//
use std::{collections::HashMap, str, sync::Arc};

use anyhow::{anyhow, Result};
use async_trait::async_trait;
use tokio::sync::Mutex;

use crate::{
    device_manager::{
        get_host_path, KATA_BLK_DEV_TYPE, KATA_MMIO_BLK_DEV_TYPE, VIRTIO_BLOCK, VIRTIO_MMIO,
    },
    device_type::{BlockDevice, Device, DeviceArgument, GenericConfig},
    DeviceManagerInner, Hypervisor,
};
use agent::types::Device as AgentDevice;
use kata_sys_util::rand;
// Device manager will manage the lifecycle of sandbox device
pub struct BlockDeviceManager {
    devices: HashMap<String, Arc<Mutex<BlockDevice>>>,
    block_driver: String,
    block_index: u64,
    released_index: Vec<u64>,
}

impl BlockDeviceManager {
    pub fn new(block_driver: &str) -> Result<Self> {
        let driver = match block_driver {
            VIRTIO_MMIO => VIRTIO_MMIO,
            VIRTIO_BLOCK => VIRTIO_BLOCK,
            // other block driver is not avaliable currently,
            _ => return Err(anyhow!("Unsupported block driver {}", block_driver)),
        };

        Ok(Self {
            devices: HashMap::new(),
            block_driver: String::from(driver),
            block_index: 0,
            released_index: vec![],
        })
    }

    async fn try_create_device(
        &self,
        dev_info: &mut GenericConfig,
    ) -> Result<Arc<Mutex<BlockDevice>>> {
        // check the valid device number
        if dev_info.major >= 0 && dev_info.minor >= 0 {
            // find /dev/xxxx
            let path = get_host_path(dev_info)?;
            dev_info.host_path = path;
        }

        // if the device is already created, just return the device
        if let Some(dev) = self
            .find_device(dev_info.major, dev_info.minor, dev_info.host_path.as_str())
            .await
        {
            return Ok(dev);
        }

        // device ID must be generated by manager instead of device itself
        // in case of ID collision
        dev_info.id = self.new_device_id()?;
        dev_info
            .driver_options
            .insert("block-driver".to_string(), self.block_driver.clone());
        Ok(Arc::new(Mutex::new(BlockDevice::new(dev_info))))
    }

    async fn find_device(
        &self,
        major: i64,
        minor: i64,
        host_path: &str,
    ) -> Option<Arc<Mutex<BlockDevice>>> {
        if major >= 0 && minor >= 0 {
            return self.find_device_by_major_minor(major, minor).await;
        }

        // the raw file as block device case
        self.find_device_by_host_path(host_path).await
    }

    async fn find_device_by_major_minor(
        &self,
        major: i64,
        minor: i64,
    ) -> Option<Arc<Mutex<BlockDevice>>> {
        for dev in self.devices.values() {
            let mm = dev.lock().await.get_major_minor().await;
            if mm.0 == major && mm.1 == minor {
                return Some(dev.clone());
            }
        }
        None
    }

    async fn find_device_by_host_path(&self, host_path: &str) -> Option<Arc<Mutex<BlockDevice>>> {
        for dev in self.devices.values() {
            if host_path == dev.lock().await.get_host_path().await {
                return Some(dev.clone());
            }
        }
        None
    }

    async fn get_device_by_id(&self, id: &str) -> Option<Arc<Mutex<BlockDevice>>> {
        self.devices.get(id).map(Arc::clone)
    }

    fn new_device_id(&self) -> Result<String> {
        for _ in 0..5 {
            let rand_bytes = rand::RandomBytes::new(8);
            let id = format!("{:x}", rand_bytes);
            if self.devices.get(&id).is_none() {
                return Ok(id);
            }
        }

        Err(anyhow!("ID are exhausted"))
    }

    // get_and_set_sandbox_block_index retrieves sandbox block index and increments it for
    // subsequent accesses. This index is used to maintain the index at which a
    // block device is assigned to a container in the sandbox.
    fn get_and_set_sandbox_block_index(&mut self) -> Result<u64> {
        let current_index = self.block_index;
        if let Some(index) = self.released_index.pop() {
            return Ok(index);
        }
        self.block_index += 1;

        Ok(current_index)
    }

    // This is used to recover from failure while adding a block device.
    // unset_sandbox_block_index add the current index to released index and sort them in order.
    fn unset_sandbox_block_index(&mut self, index: u64) -> Result<()> {
        self.released_index.push(index);
        self.released_index.sort_by(|a, b| b.cmp(a));
        Ok(())
    }

    // get_virt_drive_name returns the disk name format for virtio-blk
    // Reference: https://github.com/torvalds/linux/blob/master/drivers/block/virtio_blk.c @c0aa3e0916d7e531e69b02e426f7162dfb1c6c0
    fn get_virt_drive_name(&self, mut index: i32) -> Result<String> {
        if index < 0 {
            return Err(anyhow!("Index cannot be negative"));
        }

        // Prefix used for virtio-block devices
        const PREFIX: &str = "vd";

        // Refer to DISK_NAME_LEN: https://github.com/torvalds/linux/blob/08c521a2011ff492490aa9ed6cc574be4235ce2b/include/linux/genhd.h#L61
        let disk_name_len = 32usize;
        let base = 26i32;

        let suff_len = disk_name_len - PREFIX.len();
        let mut disk_letters = vec![0u8; suff_len];

        let mut i = 0usize;
        while i < suff_len && index >= 0 {
            let letter: u8 = b'a' + (index % base) as u8;
            disk_letters[i] = letter;
            index = (index / base) - 1;
            i += 1;
        }
        if index >= 0 {
            return Err(anyhow!("Index not supported"));
        }
        disk_letters.truncate(i);
        disk_letters.reverse();
        Ok(String::from(PREFIX) + std::str::from_utf8(&disk_letters)?)
    }
}

#[async_trait]
impl DeviceManagerInner for BlockDeviceManager {
    async fn try_add_device(
        &mut self,
        dev_info: &mut GenericConfig,
        h: &dyn Hypervisor,
    ) -> Result<String> {
        let dev = self.try_create_device(dev_info).await?;
        let id = dev.lock().await.device_id().await.to_string();
        let skip = dev.lock().await.increase_attach_count().await?;
        if skip {
            return Ok(id);
        }

        let blk_dev = Arc::new(Mutex::new(BlockDevice::new(dev_info)));
        self.devices.insert(id.clone(), blk_dev);

        // prepare arguments to attach device
        let index = self.get_and_set_sandbox_block_index()?;
        let drive_name = self.get_virt_drive_name(index as i32)?;

        // attach device
        let attach_device_future = async {
            if let Some(dev) = self.devices.get(&id) {
                dev.lock()
                    .await
                    .attach(
                        h,
                        DeviceArgument {
                            index: Some(index),
                            drive_name: Some(drive_name),
                        },
                    )
                    .await?;
            } else {
                return Err(anyhow!(
                    "device with specified ID hasn't been created. {}",
                    id
                ));
            }
            Ok(())
        };

        if let Err(e) = attach_device_future.await {
            dev.lock().await.decrease_attach_count().await?;
            self.unset_sandbox_block_index(index)?;
            self.devices.remove(&id);
            return Err(e);
        }

        Ok(id)
    }

    async fn try_remove_device(&mut self, device_id: &str, h: &dyn Hypervisor) -> Result<()> {
        if let Some(dev) = self.devices.get(device_id) {
            let skip = dev.lock().await.decrease_attach_count().await?;
            if skip {
                return Ok(());
            }

            if let Err(e) = dev.lock().await.detach(h).await {
                dev.lock().await.increase_attach_count().await?;
                return Err(e);
            }
            self.devices.remove(device_id);
        } else {
            return Err(anyhow!(
                "device with specified ID hasn't been created. {}",
                device_id
            ));
        }

        Ok(())
    }

    async fn generate_agent_device(&self, device_id: String) -> Result<AgentDevice> {
        // Safe because we just attached the device
        let dev = self.get_device_by_id(&device_id).await.unwrap();
        let base_info = dev.lock().await.get_device_info().await?;
        let mut device = AgentDevice {
            container_path: base_info.container_path.clone(),
            ..Default::default()
        };

        match self.block_driver.as_str() {
            VIRTIO_MMIO => {
                if let Some(path) = base_info.virt_path {
                    device.id = device_id;
                    device.field_type = KATA_MMIO_BLK_DEV_TYPE.to_string();
                    device.vm_path = path;
                }
            }
            VIRTIO_BLOCK => {
                if let Some(path) = base_info.pci_addr {
                    device.id = device_id;
                    device.field_type = KATA_BLK_DEV_TYPE.to_string();
                    device.vm_path = path;
                }
            }
            _ => (),
        }
        Ok(device)
    }

    async fn get_device_guest_path(&self, id: &str) -> Option<String> {
        if let Some(device) = self.devices.get(id) {
            if let Ok(dev_info) = device.lock().await.get_device_info().await {
                return dev_info.virt_path;
            }
        }
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_virt_drive_name() {
        let blk_manager = BlockDeviceManager::new(VIRTIO_MMIO).unwrap();
        for &(input, output) in [
            (0i32, "vda"),
            (25, "vdz"),
            (27, "vdab"),
            (704, "vdaac"),
            (18277, "vdzzz"),
        ]
        .iter()
        {
            let out = blk_manager.get_virt_drive_name(input).unwrap();
            assert_eq!(&out, output);
        }
    }
}
