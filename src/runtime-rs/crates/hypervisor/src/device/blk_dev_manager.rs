// Copyright (c) 2019-2022 Alibaba Cloud
// Copyright (c) 2019-2022 Ant Group
//
// SPDX-License-Identifier: Apache-2.0
//
use std::{collections::HashMap, str, sync::Arc};

use anyhow::{anyhow, Context, Result};
use async_trait::async_trait;
use tokio::sync::Mutex;

use crate::{
    device_manager::{
        get_host_path, KATA_BLK_DEV_TYPE, KATA_MMIO_BLK_DEV_TYPE, VIRTIO_BLOCK_MMIO,
        VIRTIO_BLOCK_PCI,
    },
    device_type::{BlockDevice, Device, DeviceArgument, GenericConfig},
    DeviceManagerInner, Hypervisor,
};
use kata_sys_util::rand;

pub struct BlockDeviceManager {
    devices: HashMap<String, Arc<Mutex<BlockDevice>>>,
    block_driver: String,
}

impl BlockDeviceManager {
    pub fn new(block_driver: &str) -> Result<Self> {
        let driver = match block_driver {
            VIRTIO_BLOCK_MMIO => VIRTIO_BLOCK_MMIO,
            VIRTIO_BLOCK_PCI => VIRTIO_BLOCK_PCI,
            // other block driver is not avaliable currently,
            _ => return Err(anyhow!("Unsupported block driver {}", block_driver)),
        };

        Ok(Self {
            devices: HashMap::new(),
            block_driver: String::from(driver),
        })
    }

    async fn try_create_device(
        &self,
        dev_info: &mut GenericConfig,
    ) -> Result<Arc<Mutex<BlockDevice>>> {
        // we use virtio-blk to handle both raw file and block device,
        // if major and minor number greater or equal to zero, blk manager will handle it as block device
        // otherwise blk manager will handle it as raw file
        if dev_info.major >= 0 && dev_info.minor >= 0 {
            // find /dev/xxxx
            let path = get_host_path(dev_info)?;
            dev_info.host_path = path;
        }

        // if the device is already created, just return the device
        if let Some(dev) = self
            .find_device(dev_info.major, dev_info.minor, dev_info.host_path.as_str())
            .await
        {
            return Ok(dev);
        }

        // device ID must be generated by manager instead of device itself
        // in case of ID collision
        dev_info.id = self.new_device_id()?;
        dev_info
            .driver_options
            .insert("block-driver".to_string(), self.block_driver.clone());
        Ok(Arc::new(Mutex::new(BlockDevice::new(dev_info))))
    }

    async fn find_device(
        &self,
        major: i64,
        minor: i64,
        host_path: &str,
    ) -> Option<Arc<Mutex<BlockDevice>>> {
        if major >= 0 && minor >= 0 {
            return self.find_device_by_major_minor(major, minor).await;
        }

        // the raw file as block device case
        self.find_device_by_host_path(host_path).await
    }

    async fn find_device_by_major_minor(
        &self,
        major: i64,
        minor: i64,
    ) -> Option<Arc<Mutex<BlockDevice>>> {
        for dev in self.devices.values() {
            let mm = dev.lock().await.get_major_minor().await;
            if mm.0 == major && mm.1 == minor {
                return Some(dev.clone());
            }
        }
        None
    }

    async fn find_device_by_host_path(&self, host_path: &str) -> Option<Arc<Mutex<BlockDevice>>> {
        for dev in self.devices.values() {
            if host_path == dev.lock().await.get_host_path().await {
                return Some(dev.clone());
            }
        }
        None
    }

    fn new_device_id(&self) -> Result<String> {
        for _ in 0..5 {
            let rand_bytes = rand::RandomBytes::new(8);
            let id = format!("{:x}", rand_bytes);
            if self.devices.get(&id).is_none() {
                return Ok(id);
            }
        }

        Err(anyhow!("ID are exhausted"))
    }
}

#[async_trait]
impl DeviceManagerInner for BlockDeviceManager {
    async fn try_add_device(
        &mut self,
        dev_info: &mut GenericConfig,
        h: &dyn Hypervisor,
        da: DeviceArgument,
    ) -> Result<String> {
        let dev = self
            .try_create_device(dev_info)
            .await
            .context("failed to create device")?;
        let id = dev.lock().await.device_id().await.to_string();
        let skip = dev
            .lock()
            .await
            .increase_attach_count()
            .await
            .context("failed to increase attach count")?;
        // we need to skip add device, if the device is already attached
        if skip {
            return Ok(id);
        }

        let blk_dev = Arc::new(Mutex::new(BlockDevice::new(dev_info)));
        self.devices.insert(id.clone(), blk_dev);

        // attach device
        let attach_device_future = async {
            if let Some(dev) = self.devices.get(&id) {
                dev.lock().await.attach(h, da).await?;
            } else {
                return Err(anyhow!(
                    "device with specified ID hasn't been created. {}",
                    id
                ));
            }
            Ok(())
        };

        if let Err(e) = attach_device_future.await {
            dev.lock().await.decrease_attach_count().await?;
            self.devices.remove(&id);
            return Err(e);
        }

        Ok(id)
    }

    async fn try_remove_device(
        &mut self,
        device_id: &str,
        h: &dyn Hypervisor,
    ) -> Result<Option<u64>> {
        if let Some(dev) = self.devices.get(device_id) {
            let skip = dev.lock().await.decrease_attach_count().await?;
            if skip {
                return Ok(None);
            }
            let result = match dev.lock().await.detach(h).await {
                Ok(id) => Ok(id),
                Err(e) => {
                    dev.lock().await.increase_attach_count().await?;
                    Err(e)
                }
            };
            if result.is_ok() {
                self.devices.remove(device_id);
            }
            return result;
        }
        return Err(anyhow!(
            "device with specified ID hasn't been created. {}",
            device_id
        ));
    }

    async fn get_device_vm_path(&self, id: &str) -> Option<String> {
        if let Some(device) = self.devices.get(id) {
            if let Ok(dev_info) = device.lock().await.get_device_info().await {
                match self.block_driver.as_str() {
                    VIRTIO_BLOCK_MMIO => {
                        return dev_info.virt_path;
                    }
                    VIRTIO_BLOCK_PCI => {
                        return dev_info.bdf;
                    }
                    _ => (),
                }
            }
        }
        None
    }

    async fn get_device_guest_path(&self, id: &str) -> Option<String> {
        if let Some(device) = self.devices.get(id) {
            if let Ok(dev_info) = device.lock().await.get_device_info().await {
                return dev_info.virt_path;
            }
        }
        None
    }

    async fn get_driver_options(&self) -> Result<String> {
        let driver = match self.block_driver.clone().as_str() {
            VIRTIO_BLOCK_MMIO => KATA_MMIO_BLK_DEV_TYPE.to_string(),
            VIRTIO_BLOCK_PCI => KATA_BLK_DEV_TYPE.to_string(),
            _ => "".to_string(),
        };
        Ok(driver)
    }
}
