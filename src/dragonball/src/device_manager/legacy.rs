// Copyright (C) 2022 Alibaba Cloud. All rights reserved.
// Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
//
// Portions Copyright 2017 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the THIRD-PARTY file.

//! Device Manager for Legacy Devices.

use std::io;
use std::sync::{Arc, Mutex};

use dbs_device::device_manager::{Error as IoManagerError, IoManager};
#[cfg(target_arch = "x86_64")]
use dbs_device::resources::Resource;
use dbs_legacy_devices::{EventFdTrigger, SerialDevice};
#[cfg(target_arch = "x86_64")]
use dbs_legacy_devices::{I8042Device, I8042DeviceMetrics};
use kvm_ioctls::VmFd;
use vmm_sys_util::eventfd::EventFd;

#[cfg(target_arch = "x86_64")]
const COM1_IRQ: u32 = 4;
#[cfg(target_arch = "x86_64")]
const COM1_PORT1: u16 = 0x3f8;
#[cfg(target_arch = "x86_64")]
const COM2_IRQ: u32 = 3;
#[cfg(target_arch = "x86_64")]
const COM2_PORT1: u16 = 0x2f8;

/// Errors generated by legacy device manager.
#[derive(Debug, thiserror::Error)]
pub enum Error {
    /// Cannot add legacy device to Bus.
    #[error("failure while managing legacy device")]
    BusError(#[source] IoManagerError),

    /// Cannot create EventFd.
    #[error("failure while reading EventFd file descriptor")]
    EventFd(#[source] io::Error),

    /// Failed to register/deregister interrupt.
    #[error("failure while managing interrupt for legacy device")]
    IrqManager(#[source] vmm_sys_util::errno::Error),
}

type Result<T> = ::std::result::Result<T, Error>;

/// The `LegacyDeviceManager` is a wrapper that is used for registering legacy devices
/// on an I/O Bus. It currently manages the uart and i8042 devices.
/// The `LegacyDeviceManger` should be initialized only by using the constructor.
pub struct LegacyDeviceManager {
    #[cfg(target_arch = "x86_64")]
    i8042_reset_eventfd: EventFd,
    com1_device: Arc<Mutex<SerialDevice>>,
    _com1_eventfd: EventFd,
    com2_device: Arc<Mutex<SerialDevice>>,
    _com2_eventfd: EventFd,
}

impl LegacyDeviceManager {
    /// Create a LegacyDeviceManager instance handling legacy devices (uart, i8042).
    #[cfg(target_arch = "x86_64")]
    pub fn create_manager(bus: &mut IoManager, vm_fd: Option<Arc<VmFd>>) -> Result<Self> {
        let (com1_device, com1_eventfd) =
            Self::create_com_device(bus, vm_fd.as_ref(), COM1_IRQ, COM1_PORT1)?;
        let (com2_device, com2_eventfd) =
            Self::create_com_device(bus, vm_fd.as_ref(), COM2_IRQ, COM2_PORT1)?;

        let exit_evt = EventFd::new(libc::EFD_NONBLOCK).map_err(Error::EventFd)?;
        let i8042_device = Arc::new(Mutex::new(I8042Device::new(
            EventFdTrigger::new(exit_evt.try_clone().map_err(Error::EventFd)?),
            Arc::new(I8042DeviceMetrics::default()),
        )));
        let resources = [Resource::PioAddressRange {
            base: 0x60,
            size: 0x5,
        }];
        bus.register_device_io(i8042_device, &resources)
            .map_err(Error::BusError)?;

        Ok(LegacyDeviceManager {
            i8042_reset_eventfd: exit_evt,
            com1_device,
            _com1_eventfd: com1_eventfd,
            com2_device,
            _com2_eventfd: com2_eventfd,
        })
    }

    /// Get the serial device for com1.
    pub fn get_com1_serial(&self) -> Arc<Mutex<SerialDevice>> {
        self.com1_device.clone()
    }

    /// Get the serial device for com2
    pub fn get_com2_serial(&self) -> Arc<Mutex<SerialDevice>> {
        self.com2_device.clone()
    }

    /// Get the eventfd for exit notification.
    #[cfg(target_arch = "x86_64")]
    pub fn get_reset_eventfd(&self) -> Result<EventFd> {
        self.i8042_reset_eventfd.try_clone().map_err(Error::EventFd)
    }

    #[cfg(target_arch = "x86_64")]
    fn create_com_device(
        bus: &mut IoManager,
        vm_fd: Option<&Arc<VmFd>>,
        irq: u32,
        port1: u16,
    ) -> Result<(Arc<Mutex<SerialDevice>>, EventFd)> {
        let eventfd = EventFd::new(libc::EFD_NONBLOCK).map_err(Error::EventFd)?;
        let device = Arc::new(Mutex::new(SerialDevice::new(
            eventfd.try_clone().map_err(Error::EventFd)?,
        )));
        let resources = [Resource::PioAddressRange {
            base: port1,
            size: 0x8,
        }];
        bus.register_device_io(device.clone(), &resources)
            .map_err(Error::BusError)?;

        if let Some(fd) = vm_fd {
            fd.register_irqfd(&eventfd, irq)
                .map_err(Error::IrqManager)?;
        }

        Ok((device, eventfd))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[cfg(target_arch = "x86_64")]
    fn test_create_legacy_device_manager() {
        let mut bus = IoManager::new();
        let mgr = LegacyDeviceManager::create_manager(&mut bus, None).unwrap();
        let _exit_fd = mgr.get_reset_eventfd().unwrap();
    }
}
